--------------------------

学籍番号 : 2030100
氏名 :　伊藤悠馬

--------------------------

回答1 :
1.1) OrderedShapeManagerの実装についての説明
利用したクラスについてや、最小限の実装行で済ませる工夫などを説明して下さい。

java.util.AbstractCollectionを継承した子クラスの子クラスであるjava.util.TreeSetを用いることでcompare()を指定することで格納されるデータをidに基づいて並べて保存した。


1.2)
空欄Aに入る語は：2)カプセル化
空欄Bに入る語は：6)モニタ




回答２ :
2.1) para.Main05のメンバ変数valueに直接関連した処理を行うスレッド名と
その役割はそれぞれ次のとおり

スレッド名                  |　役割
---------------------------------------------------------------------------------------------------
JavaFX Application Thread　| スライダーの値が変更された後valueの値を変更する役割
Thread-4　                 |　ウィンドウを生成したり、常に描画を繰り返すことで変更を行う役割





2.2)
ユーザ視点でのプログラムの不具合
volatileがついていない場合、スライダーで行った値の変更が瞬時に反映されない可能性がある。





不具合の原因についての講義で説明されたプログラムを処理する仕組みに基づいた説明
この原因としてはvolatileがついていないことでスライダーの値とMain05のstart()が実行されているスレッドのvalueの値が異なる問題が起きてしまう可能性がある。
スレッドが複数実行されている場合利用する変数のコピーを用いることがある。
その際にvalueにvolatileがついていない状態ではそのコピーと本体との間に同期が取られているとは限らず、値がずれてしまう可能性がある。




回答3 :
3.1)
配布されたpara.Main06による仕様のように動かない挙動の説明
配布されたコードでは二つのウィンドウに表示されている数字の片方がもう片方の数字と同じ数字になってしまうという問題がある。
つまりincremetとdecrementで表示されているウィンドウの数字がそれぞれ増加、減少を行っていくのが想定される挙動であるが、
今回のコードではそれぞれのウィンドウの数字がそれぞれ増加、減少を行う中、ときどき二つが同じ数字になることがある。
この原因としてsm2 = sm1がshallowコピーを行なってしまっている点にある。
そのためぱっと見はsm1, sm2がそれぞれ別のものを指しているように見えて同じものを参照している。
二つのウィンドウの数字の変更を行う際、変数の変更を各スレッドが順に行なっていれば動作はうまくいくものの、
sm1とsm2という形で同じ変数を共有しているために、二つのスレッドの変数操作が入り乱れて、あるスレッドの変数smへの操作途中に別のスレッドが変数smへの操作を行うことで
今回のように数字が時々同期してしまうという現象が発生してしまう。

3.2)
つぎのどちらかの行を消して回答せよ

メソッドduplicate()は deep copy である

スレッドセーフであると考える場合、その理由の説明

まずスレッドts1, ts2のインスタンス生成時に与えている引数を確認する。t1,t2はJavaFXTargetクラスのインスタンスとして新規に生成されておりJavaFXTargetクラスではクラス外の変数を変更していない。
さらにsm1, sm2はduplecate()で実装しているため変数の共有は起きていない。
次にRunnerクラスを見る。ここで使われている変数はtarget, sm, add, i, Threadであるが、target, sm, addは上記で非共有であることが確認されている。
iはこのクラスで定義されるローカル変数であり、Threadも各スレッド自身をさすため非共有である。
これによりこれら二つのスレッドは変数を非共有であり、スレッドセーフである。



回答4 :
4.1)
２つのスレッド
１つ目のスレッドとその役割は次のとおり




２つ目のスレッドとその役割は次のとおり




4.2)
para.game.GameFrameのメンバ変数xyについてsynchronizedメソッドによる同
期を行わなかった場合に生じる不正確なデータの処理の例は次のとおり





volatile修飾では不十分であることの理由






4.3)
para.game.GameFrameのメンバ変数leftonやrightonにvolatile修飾を付けるこ
とでマルチスレッドに対応できることの説明







4.4)
ゲーム性を高めるために行った実装についての説明
得点ルールとその計算法の実装





得点を表示するために行った実装






課題3で表示される図形を利用するための実装






ゲームの終了条件を定めるための実装






4.5)
更なるゲーム性の向上のための追加実装についての説明









工夫した点や感想：

