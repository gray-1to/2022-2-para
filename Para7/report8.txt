--------------------------

学籍番号 : 20B30100
氏名 : 伊藤悠馬

--------------------------

回答3 :
3.1) ２つ目のソケット接続が開始した後で、それぞれのゲームが開始される
ようにした変更箇所の説明

GameServerFrameで2つの接続があってはじめてゲームの処理を行うように変更した。
GameServerFrameでは次の接続が何番目かをusersという変数で管理している。
GameServer01へ接続情報をqueue経由で渡しているため、usersが1のとき(1番初め)の接続情報はarrayのみに保存しておき、
usersが2のときに1番初めの接続情報と2番目の接続情報をqueueにいれてGameServer01に渡している。
これにより接続数が2になって初めてゲームが開始するようになっている。
一度接続が切れてしまっても残されたプレーヤーはゲームを続行し、接続が切れたプレーヤーも再接続した際にもう一度プレーできるように
from_first_threadというフラグをもちいて、usersが2であるときに残っている接続情報をqueueに登録するか判断している。


3.2)
ゲームの終了条件
（3.4と合わせて回答したい場合は、「3.5)の回答を参照」と記すこと)

3.5)の回答を参照


実装方針

3.5)の回答を参照


ソースコード中の実装部分

3.5)の回答を参照




3.3)
空欄A:thread
空欄B:JavaFX Application Thread
空欄C:Thread-6

スレッドセーフで　ある
スレッドセーフであると考える理由

判定に用いられている変数threadにはvolatileが付けられており各スレッドでの安全性は保障されている。



3.4)
対戦ゲームのルール説明
（利用者に説明する遊び方）

2名が接続されたらゲームが始まる。
自分が操作できるバーにボールを当てると上方向にランダムの角度でボールがバウンドする。
ボールをブロックに当てて壊した数が得点になる。
底面にボールが触れるとゲーム終了であるが、100点以上の得点を持っている場合には100点を消費することでゲームを続行する。


ゲーム性を高めるためにルールで工夫した点

毎回同じバウンドで軌道が似通っていると飽きてしまうのでランダム要素を組み込んだ。
さらに角度がランダムのバウンドにすることで突然の角度変化による咄嗟の判断が求められる場合がありスリルがでた。
100点を消費することでゲームを続行できるというルールにおいては100点を消費した後にすぐゲームオーバーになり得点が下がる可能性があるため、
先に底面にゲームを終了してしまった人へ勝機を残しているおり、終わってしまってもゲームを楽しむことができる。


ルールを実現するためにどう実装したかを説明

ボールのバウンドのランダム性はボールがボードに当たった時の速度ベクトルをランダムな角度に回転させるという方法で実装している。
GameServer01の191行目以降で速度ベクトルを速度ベクトルの長さを乱数分だけ傾けたベクトルにすることで回転を実現する。
底面をdeadwというShapeManagerに登録し他の壁と同じようにGameServerの208行目で衝突判定を行なっている。
接触が確認され次第、そのプレイヤーの終了フラグeach_game_finish[]をtrueとしている。
この際に得点が100点以上か確認することで100点以上の人はゲームを続行できるようにしている。



ゲーム画面の改良点など、配布プログラムから改良した点

ボールの初期位置が低すぎるため、クライアント側でのバーの生成がカメラ接続による遅延のため間に合わず、
ゲームオーバーになってしまうため、ボールの生成位置を画面中央付近にした。
バーの移動速度を上げた。




3.5)
勝敗決定規則の説明

100点以下で底面に触れるとそのプレーヤーの操作が終了する。
全プレーヤーが操作を終了したときに最も得点をとっていたプレーヤーが勝者である。
同点の時には後にゲーム開始ボタンを押した人が敗者となる。


勝敗決定規則の実装法の説明・ソースコード中の実装部分

衝突判定を行なっている部分のGameServer01の208行目でプレーヤーの操作終了条件を満たす時、各プレーヤーに対応づけたeach_game_finish[]というフラグを各プレーヤーのプレー終了時に立てる。
GameServer01のstart()内で114行目で各whileループでeach_game_finishフラグが全員立っていることが確認できたら123行目以降で最小の得点を持っているプレーヤーを割り出しidを特定している。
このidをGameServerFrameのfinish()に渡している。
GameServerFrame142行目のfinishでは敗北感をだすフィルターへの変更命令を送信した後、新しくスレッドを作りその中で10秒間待ったのちにuseroutput[]の各要素でfinish()をよびだすことで接続を終了している。
接続が格納されていないuseroutput[]にはnullが格納されているのでnullを条件分岐で避けている。




3.6)
敗北感を表現するための画像加工フィルタの設計意図の説明
（どのように敗北感を演出するか）

悲しみを表現するために画像の青色のみを抽出するフィルターを設計した。



フィルタの実装法の説明
（技術的に、どのような演算を行ったかを説明）

具体的には青色成分のみを引き継ぎ、赤、緑の色成分を0にする演算を行なっている。



実装部分についての説明
(どのファイルのどの部分を変更して、ゲーム終了時の勝敗に従い、敗者側のカメラ
にのみ画像加工を施すよう実装したかを解説)

クライアントにフィルターを替えるよう命令する命令文を出力する関数drawCameraFilter()をTextTargetクラスに作成した。
この際、クライアント側でGameMainParserが呼ばれるように初めの単語をgameとしている。
このdrawCameraFilter()をゲームセット時に呼ばれるGameServerFrameのfinish()内で呼び出すことで敗北したクライアントにフィルター変更命令を送信している。
クライアント側では受け取った命令をパースできるようGameMainParser内の29行目でパース用の処理を設定している。
そしてGame04の107行目でフィルター変更命令パース時に呼ばれるsetCameraFilter()を定義し作成したフィルターをもつTargetImageFilterを再作成している。
上記の流れでフィルターを変更するdrawCameraFilter()を終了時にGameServerFrameのfinish()内で呼び出すことで実装している。

3.7)
録画したファイル名とおよその再生時間

game2030100.mp4

35秒

ゲームルールが分かる楽しく対戦（風）ゲームをしている映像を録画するために工夫した点、行ったこと

実際に友人と計算機室のパソコンを用いて対戦した。













------
来年度に向けた講義演習についての質問

講義・演習課題全体で一番記憶に残っている事柄は

並列処理で実行タイミングによってバグが起こるためバグの再現性が低いこと。


演習で一番大変だった課題は何回目の何番目ですか
第　　　4回の　　　5番目


演習で一番将来役立ちそうだと思った課題は何回目の何番目ですか
第　　　4回の　　　5番目


今この講義演習に関連してより詳しく知りたいと思うこと（何点でも）

OpenCLで画像以外に処理できるものについて。



お疲れ様でした。





