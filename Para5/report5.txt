--------------------------

学籍番号 : 20B30100

氏名 : 伊藤悠馬

--------------------------

回答1 :
1.1) 空欄に入る数は以下のとおり

A: 2^24 = 16777216

B: 4^3 = 64

C: 2^24 = 16777216

1.2)
並列化で問題となるStreamの処理の番号

1番目のStream処理


1.3)単純に並列化したのでは結果が異なる原因

1番目のStream処理ではaveの最も距離が近かった要素にr,g,bの値を足しているが単純な並列化では同期が取られておらず、同じインデックスに足し算をする処理が連続するなどしたとき足し算の結果が反映されない可能性がある。




1.4)並列化に対応するために行った変更点

並列化された各要素から同時に同一の要素にアクセスされてしまうと競合が起きてしまうので、
1番目のStream処理の結果であるlabel変数のaveへの格納をStream外で行うように変更した。





回答2 :
2.1)
出力される時間の意味

100回の当たり判定にかかった時間

達成された高速化の数値的説明

5回の計測では
SINGLE:49171msec 47988msec 42986msec4 7601msec 47273msec
PARALLEL:31166msec 32520msec 36070msec 28598msec 31349msec
となりそれぞれ平均
SINGLE:47003.8msec
PARALLEL:31940.6msec
という結果となった。
並列化を取り入れることで約68%の実行時間で留めることが可能になった。

計測時間の信頼性を向上させるために行った工夫、計測で注意した点

他のプロセスからの影響を考え、psコマンドで他のプロセスの実行状況が変わっていないことを確かめてから実行を行なった。
各実行時間にはばらつきがあることを想定し、SINGLEとPARALLELの各場合で5回ずつ計測を行った。



2.2)
衝突判定部分の高速化についてのjvisualvmを使用した調査方法の説明

SINGLEとPARALLELのそれぞれを実行し、衝突判定を行うスレッド（自分の場合はThread-3）のgraphic.shape.CollisionCheckerParallel2のCPU占領時間を調べた。


調査により判明した衝突判定部分の高速化前後の処理速度の比率

結果は
SINGLE:14294ms
PARALLEL:8471ms
となり、実行時間は並列化することで約59%となった。



2.3)
発見された改善対象のコード部分

visualvmを用いて実行時間を見てみるとShapeManager.remove()が多くの実行時間を占めている。
この部分のコードを見るとシングルスレッドで削除対象を総当たりで探していることからこの部分を並列ストリームで実装することで実行時間の短縮を図る。


改良方針

削除対象のオブジェクトをdataコレクションから探すという探索を並列ストリームで実装する。
コレクションの各要素を並列して判定したいので、一度配列に直してからインデックスを用いてアクセスをし、削除対象のオブジェクトを描画をしないShapeオブジェクトであるBlankオブジェクトに置き換えることで削除を行なっている。
この部分の並列ストリーム内ではdataを配列化したarray_data配列の各要素にしか変更を行わないため、安全である。

2.4)2.3で行った改良部分の改良前後の処理時間について

処理時間の定義

2.3で着目したShapeManager.remove()のCPU利用時間を処理時間の定義とする。
今回の並列ストリーミングで改善されるのはremove()実行時の削除対象の削除（変更）が中心であるからである。
その他の部分の実行時間、特にCollisionCheckerParallel2.check()の部分は増加することが予想される。
これはremove()でBlankオブジェクトへの置き換えという形での削除となったため、check()で確認しなければならないオブジェクトが減らなくなってしまったためである。


改良前と比べ改良後の処理時間は約79％となった



回答3 :
3.1)ゲーム性を高めるための実装
得点ルールの定義

ピンク色のブロックを一つ壊すごとに一点が加算される。
球が底面に触れるまでに何点取れたかを競う。
新しくゲームを始めるごとに得点を初期化する。


得点計算のコード部分について

得点計算のコードはMain11.javaに集中している。
初期化時に呼び出すinit()で得点を0にしている。
さらに当たり判定を行なっているスレッド内でブロックの当たり判定の部分で得点を1ずつプラスしている。


得点表示のためのコード部分について

Main11.gamestart()内で衝突判定を行うスレッドで得点表示を行なっている。
177行目からのfor文で古い得点表示を削除している。
180行目以降で得点の格桁をDigit型で登録し、198行目で描画している。


ゲームの終了条件の定義

ボードの底面に球が触れてしまったらゲームオーバー。


ゲームの終了判定のコード部分について

38行目で底面の壁をOrderdShapeManager型のdeadwall変数に登録している。
そしてブロックや壁との接触判定を行う部分(151行目)でdeadwallとの接触も判定し、接触している場合はこのスレッドのループを管理するball_aliveというフラッグをfalseに変更したのち、timeを0にしている。
これにより底面に接触するとこのスレッドが終了し、ボールの動きが止まりゲームが停止状態になる。
そしてthread変数をnullにすることでgamestart()の始めの条件分岐で引っかからないようになっている。
そのためまた新しくゲームを始めるボタンを押しゲームを開始することができる。



スタートボタンを押した際の新たな初期化処理について

gamestart()のループ前で初期化処理を行なっている。
startボタンを押されたときイベントハンドラでgamestart()を実行している。
43行目からのinit()では各ShapeManagerの初期化、得点の初期化を行っている。
さらにgamestart()では各ブロックの登録、描画をおこなっている。


ゲームの難易度の方針

ゲーム難易度によってブロックの数を増やすようにした。
gamestart()の始め部分でのブロックの初期化部分(72行目)にて難易度によってブロックの数を増やしていき、ブロックの大きさもそれに応じて小さくしている。


数値選択とゲーム難易度についての実装部分について

難易度選択の部分はSpinner<Integer>で実装している。
このspinnerの数字を引数としてgamestart()を呼び出すことで72行目以降でのブロックの数増加を実装している。
つまりstartボタンが押された際のイベントハンドラでspinnerの数字を引数としたgamestart()を呼び出している。
gamestart()では72行目以降で縦に難易度*3、横に難易度*6の数のブロックを順に生成、登録を行なっている。


3.2)さらなるゲーム性を高めるための実装
実装方針

ブロック崩しのようにボールを底面につけないよう自分のバーを上下に動かせるようにした。


実装箇所

GameFrameの179行目以降にて ,Y ,U ,V ,B ,Nキーを押した際に自分のバーを移動させるためのフラグを実装している。
Game03では壁を登録してあるShapeManagerであるwallのid:10が自分のバーとして登録しておりそれを削除、再登録することでバーの移動を表現している。
115行目以降でupon等のフラグが立ったならid:10をwallから削除。
バーのy座標を登録しているmybar_yを20減らしたのちに移動後の座標にRectangleインスタンスを登録している。
V ,B ,Nキーを押した際の下側への移動も同様。


今回の課題で特に学べたと感じたこと

ストリームを通した並列処理について理解が深まった。